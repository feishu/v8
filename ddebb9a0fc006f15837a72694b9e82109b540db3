{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c7df3ef7_8407483b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-11-14T12:24:14Z",
      "side": 1,
      "message": "Andreas, you were looking into this too, can you take a look?",
      "revId": "ddebb9a0fc006f15837a72694b9e82109b540db3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c6f72f05_f11cdf1e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-11-14T12:25:17Z",
      "side": 1,
      "message": "btw do you have a benchmark that you were measuring this on? For our own profiling.",
      "revId": "ddebb9a0fc006f15837a72694b9e82109b540db3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df3bcffa_8973be84",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2024-11-14T15:44:12Z",
      "side": 1,
      "message": "I would also be interested in the benchmark. My own measurements suggested that for short strings, `FastOneByteString` is faster, but for longer strings, `ValueView` is actually faster.",
      "parentUuid": "c6f72f05_f11cdf1e",
      "revId": "ddebb9a0fc006f15837a72694b9e82109b540db3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8cb185ed_9f03d92c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1437132
      },
      "writtenOn": "2024-11-14T19:24:57Z",
      "side": 1,
      "message": "I just added a function to d8 with fast/slow impl:\n```\nvoid Slow(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info) {\n  v8::String::ValueView view(info.GetIsolate(), info[0].As\u003cv8::String\u003e());\n  info.GetReturnValue().Set(view.length());\n}\n\nint Fast(v8::Local\u003cv8::Object\u003e recv, Local\u003cValue\u003e arg) {\n  v8::Isolate* isolate \u003d v8::Isolate::GetCurrent();\n  v8::String::ValueView view(isolate, arg.As\u003cv8::String\u003e());\n  return view.length();\n}\n```\nand then I profile various loops calling it with `prof`. It is definitely faster to use v8::Value+ValueView in a fast call for non-flat/2byte strings, since SeqOneByteString can\u0027t handle those cases. The only regression we observe is with flat 1byte strings, and string length does not seem to be a factor.",
      "parentUuid": "df3bcffa_8973be84",
      "revId": "ddebb9a0fc006f15837a72694b9e82109b540db3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5972b25_d99085b9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2024-11-15T08:48:18Z",
      "side": 1,
      "message": "Ah, okay, in my measurements I accessed the string and summed up all letters, and I loaded the isolate from the `FastApiCallbackOptions`, which I think is slightly faster. Did you try to measure with a PGO build? And on what device did you measure?\n\nBtw, I\u0027m just asking because I\u0027m interested, not to block this CL.",
      "parentUuid": "8cb185ed_9f03d92c",
      "revId": "ddebb9a0fc006f15837a72694b9e82109b540db3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42c82a1f_5dd1add6",
        "filename": "src/api/api.cc",
        "patchSetId": 1
      },
      "lineNbr": 11053,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2024-11-14T15:44:12Z",
      "side": 1,
      "message": "It\u0027s not necessary to create this scope here, is it? Could we put a marker into `no_gc_debug_scope_` instead, so that we know in the destructor that nothing has to be done?",
      "range": {
        "startLine": 11053,
        "startChar": 34,
        "endLine": 11053,
        "endChar": 68
      },
      "revId": "ddebb9a0fc006f15837a72694b9e82109b540db3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}